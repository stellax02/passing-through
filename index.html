<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Passing Through</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <meta name="theme-color" content="#020617" />
    <link rel="icon" href="favicon.ico" sizes="any" />
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png" />
    <style>
      :root { color-scheme: dark; }

      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overscroll-behavior: none;
        overflow: hidden;
      }

      body {
        background:
          radial-gradient(circle at 15% 12%, rgba(56, 189, 248, 0.22), rgba(2, 6, 23, 0) 40%),
          radial-gradient(circle at 90% 85%, rgba(168, 85, 247, 0.22), rgba(2, 6, 23, 0) 45%),
          radial-gradient(circle at 40% 75%, rgba(34, 197, 94, 0.12), rgba(2, 6, 23, 0) 55%),
          radial-gradient(circle at top left, #020617, #0b1120 30%, #020617 100%);
        display: grid;
        place-items: center;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      }

      .stage {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 12px;
        padding: 12px;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        touch-action: none;
      }

      /* ✅ 9:16 portrait */
      .canvas-wrapper {
        position: relative;
        aspect-ratio: 9 / 16;
        width: min(calc(100vw), calc((100vh - 90px) * 9 / 16));
        border-radius: 1.5rem;
        overflow: hidden;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.9);
        border: 1px solid rgba(168, 85, 247, 0.28);
        background: #020617;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
        background: #020617;
      }

      .title-pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        padding: 10px 14px;
        border-radius: 999px;
        background: rgba(2, 6, 23, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.22);
        box-shadow: 0 16px 35px rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        user-select: none;
        max-width: min(92vw, 720px);
        text-align: center;
      }

      .palette-swatch {
        width: 14px;
        height: 14px;
        border-radius: 6px;
        background: #a855f7;
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.06), 0 10px 20px rgba(0, 0, 0, 0.4);
        flex: 0 0 auto;
      }

      .title-text {
        font-size: 13px;
        letter-spacing: 0.2px;
        color: rgba(255, 255, 255, 0.92);
        font-weight: 760;
        line-height: 1.1;
      }

      .controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap;
        padding-bottom: 4px;
      }

      .btn {
        appearance: none;
        border: 1px solid rgba(148, 163, 184, 0.22);
        background: rgba(2, 6, 23, 0.55);
        color: rgba(255, 255, 255, 0.92);
        padding: 10px 14px;
        border-radius: 999px;
        font-weight: 700;
        letter-spacing: 0.2px;
        cursor: pointer;
        box-shadow: 0 16px 35px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        user-select: none;
      }
      .btn:active { transform: translateY(1px); }
      .btn[disabled] { opacity: 0.55; cursor: not-allowed; }

      .status {
        font-size: 12px;
        color: rgba(226, 232, 240, 0.85);
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(2, 6, 23, 0.35);
      }

      a.btn { text-decoration: none; display: inline-flex; align-items: center; }
    </style>
  </head>
  <body>
    <div class="stage" id="stage">
      <div class="canvas-wrapper" id="canvasWrap">
        <canvas id="field"></canvas>
      </div>

      <div class="title-pill" id="title-pill" aria-live="polite">
        <span class="palette-swatch" id="palette-swatch"></span>
        <span class="title-text" id="title-text">Holo Blocks • Palette</span>
      </div>

      <!-- <div class="controls" aria-label="Controls">
        <button class="btn" id="btnReseed" title="Reseed palette + layout (or tap the canvas)">Reseed</button>
        <button class="btn" id="btnRecord" title="Records a perfect 18s looping WebM at 1080×1920">Record 18s Loop</button>
        <button class="btn" id="btnStop" disabled>Stop</button>
        <a class="btn" id="btnDownload" style="display:none" download>Download video</a>
        <span class="status" id="status">Tap canvas to reseed • Space = pause • S = screenshot</span>
      </div> -->
    </div>

    <script>
      const canvas = document.getElementById("field");
      const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true }) || canvas.getContext("2d");

      // ---------------------------
      // Palettes (kept from your original file)
      // ---------------------------
      const PALETTES = [
        { name: "Opal Sheen", slug: "opal-sheen", colors: ["#05060A", "#F6F2FF", "#40E0FF", "#FF4FD8"] },
        { name: "Prism Aurora", slug: "prism-aurora", colors: ["#0A1020", "#7B61FF", "#35F4C6", "#FFE66D"] },
        { name: "Oil Slick", slug: "oil-slick", colors: ["#05060A", "#2B2F36", "#3DF2FF", "#B8FF3D"] },
        { name: "Laser Orchid", slug: "laser-orchid", colors: ["#060518", "#FF4FD8", "#7B61FF", "#4DFFF3"] },
        { name: "Chrome Candy", slug: "chrome-candy", colors: ["#0B0B0C", "#DDE3F0", "#FF3EA5", "#2AF1FF"] },
        { name: "Pearl Neon", slug: "pearl-neon", colors: ["#0B1026", "#F3F0E8", "#22C55E", "#60A5FA"] },
        { name: "Glacier Holo", slug: "glacier-holo", colors: ["#06101C", "#A7C7E7", "#7CE7FF", "#FF5FA2"] },
        { name: "Unicorn Plastic", slug: "unicorn-plastic", colors: ["#0B0B0C", "#F6F2FF", "#A855F7", "#34D399"] },
        { name: "CD Rainbow", slug: "cd-rainbow", colors: ["#070915", "#F3F0E8", "#00D9FF", "#F7D200"] },
        { name: "Iridescent Ink", slug: "iridescent-ink", colors: ["#05060A", "#111827", "#6EE7FF", "#D946EF"] },
        { name: "Biochrome", slug: "biochrome", colors: ["#05060A", "#E5E7EB", "#22D3EE", "#A3E635"] },
        { name: "Vapor Holo", slug: "vapor-holo", colors: ["#0B1026", "#FF5FA2", "#60A5FA", "#F3F0E8"] },
        { name: "Synth Foil", slug: "synth-foil", colors: ["#05060A", "#C7A34A", "#7CE7FF", "#FF2DAA"] },
        { name: "Aurora Lime", slug: "aurora-lime", colors: ["#05060A", "#B8FF3D", "#35F4C6", "#7B61FF"] },
        { name: "Electric Opaline", slug: "electric-opaline", colors: ["#060518", "#F6F2FF", "#2AF1FF", "#FF3EA5"] },
        { name: "Holo Titanium", slug: "holo-titanium", colors: ["#0B0B0C", "#2B2F36", "#DDE3F0", "#7CE7FF"] },
        { name: "Spectral Rose", slug: "spectral-rose", colors: ["#05060A", "#F6F2FF", "#FB7185", "#22D3EE"] },
        { name: "Mint Prism", slug: "mint-prism", colors: ["#06101C", "#34D399", "#7B61FF", "#F6F2FF"] },
        { name: "Holo Sunset", slug: "holo-sunset", colors: ["#0A1020", "#FF7849", "#FF4FD8", "#40E0FF"] },
        { name: "Cosmic Foil", slug: "cosmic-foil", colors: ["#05060A", "#7B61FF", "#FF4FD8", "#FFE66D"] },
        { name: "Sterling Aura", slug: "sterling-aura", colors: ["#0B0B0C", "#DDE3F0", "#60A5FA", "#A855F7"] },
        { name: "Prismatic Sea", slug: "prismatic-sea", colors: ["#051225", "#22D3EE", "#35F4C6", "#F6F2FF"] },
        { name: "Neon Cellophane", slug: "neon-cellophane", colors: ["#05060A", "#F6F2FF", "#A3E635", "#FF5FA2"] },
        { name: "Laser Ice", slug: "laser-ice", colors: ["#06101C", "#7CE7FF", "#F6F2FF", "#7B61FF"] }
      ];

      // ---------------------------
      // Helpers
      // ---------------------------
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      function hexToRgb(hex) {
        const h = hex.replace("#", "").trim();
        const s = h.length === 3 ? h.split("").map((c) => c + c).join("") : h;
        const n = parseInt(s, 16);
        return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
      }

      function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h = 0, s = 0;
        const l = (max + min) / 2;
        const d = max - min;
        if (d !== 0) {
          s = d / (1 - Math.abs(2 * l - 1));
          switch (max) {
            case r: h = ((g - b) / d) % 6; break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h *= 60;
          if (h < 0) h += 360;
        }
        return { h, s: s * 100, l: l * 100 };
      }

      function hexToHsl(hex) {
        const { r, g, b } = hexToRgb(hex);
        return rgbToHsl(r, g, b);
      }

      function shuffleInPlace(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }

      // ---------------------------
      // Palette state
      // ---------------------------
      const PALETTE_HSL = PALETTES.map((p) => p.colors.map(hexToHsl));
      let paletteMode = 0;
      let lastPaletteMode = null;
      let paletteBag = [];

      let bgHue = 220, bgSat = 26, bgLight = 7;

      function getPaletteSlug() { return PALETTES[paletteMode]?.slug || `palette-${paletteMode}`; }
      function getPaletteName() { return PALETTES[paletteMode]?.name || `Palette ${paletteMode}`; }

      function refillPaletteBag() {
        paletteBag = Array.from({ length: PALETTES.length }, (_, i) => i);
        shuffleInPlace(paletteBag);
        if (lastPaletteMode !== null && paletteBag.length > 1 && paletteBag[paletteBag.length - 1] === lastPaletteMode) {
          const j = paletteBag.findIndex((v) => v !== lastPaletteMode);
          if (j >= 0) [paletteBag[j], paletteBag[paletteBag.length - 1]] = [paletteBag[paletteBag.length - 1], paletteBag[j]];
        }
      }

      function drawPaletteModeFromBag() {
        if (paletteBag.length === 0) refillPaletteBag();
        let candidate = paletteBag[paletteBag.length - 1];
        if (lastPaletteMode !== null && candidate === lastPaletteMode) {
          for (let i = 0; i < paletteBag.length - 1; i++) {
            if (paletteBag[i] !== lastPaletteMode) {
              [paletteBag[i], paletteBag[paletteBag.length - 1]] = [paletteBag[paletteBag.length - 1], paletteBag[i]];
              break;
            }
          }
        }
        return paletteBag.pop();
      }

      function reseedBackgroundFromPalette() {
        const hsls = PALETTE_HSL[paletteMode] || PALETTE_HSL[0];
        let darkest = hsls[0];
        for (const c of hsls) if (c.l < darkest.l) darkest = c;

        bgHue = darkest.h;
        bgSat = clamp(darkest.s * 0.55, 10, 36);
        bgLight = clamp(darkest.l * 0.28, 3, 10);

        bgHue = (bgHue + (Math.random() * 22 - 11) + 360) % 360;
        bgSat = clamp(bgSat + (Math.random() * 8 - 4), 8, 40);
        bgLight = clamp(bgLight + (Math.random() * 2 - 1), 2.6, 11);
      }

      function applyPaletteMode(mode) {
        paletteMode = clamp(mode | 0, 0, PALETTES.length - 1);
        lastPaletteMode = paletteMode;
        reseedBackgroundFromPalette();
      }

      function reseedPalette() { applyPaletteMode(drawPaletteModeFromBag()); }

      function pickPaletteAccentHex() {
        const colors = PALETTES[paletteMode]?.colors || PALETTES[0].colors;
        const hsls = PALETTE_HSL[paletteMode] || PALETTE_HSL[0];
        let bestI = 0, bestScore = -Infinity;
        for (let i = 0; i < colors.length; i++) {
          const c = hsls[i];
          const vis = 1 - Math.abs(c.l - 55) / 55;
          const score = vis * (0.75 + c.s / 110);
          if (score > bestScore) { bestScore = score; bestI = i; }
        }
        return colors[bestI] || colors[0];
      }

      function pickPaletteColorHsl() {
        const arr = PALETTE_HSL[paletteMode] || PALETTE_HSL[0];
        // bias away from extremes and toward saturation
        const weights = arr.map((c) => {
          const mid = 1 - Math.abs(c.l - 55) / 55;
          const satBoost = 0.7 + (c.s / 100) * 0.9;
          const avoidExtremes = c.l < 10 || c.l > 94 ? 0.35 : 1.0;
          return Math.max(0.06, mid * satBoost * avoidExtremes);
        });
        let sum = 0;
        for (const w of weights) sum += w;
        let r = Math.random() * sum;
        for (let i = 0; i < weights.length; i++) {
          r -= weights[i];
          if (r <= 0) return arr[i];
        }
        return arr[arr.length - 1];
      }

      function updateTitlePill() {
        const textEl = document.getElementById("title-text");
        const swatchEl = document.getElementById("palette-swatch");
        textEl.textContent = `Holo Blocks • ${getPaletteName()}`;
        swatchEl.style.background = pickPaletteAccentHex();
      }

      function updateSeedInUrl() {
        const paletteSlug = getPaletteSlug();
        const randomPart = Math.random().toString(36).slice(2, 8);
        const seedStr = `holo-blocks-${paletteSlug}-${randomPart}`;
        const url = new URL(window.location.href);
        url.searchParams.set("seed", seedStr);
        window.history.replaceState({}, "", url);
      }

      // ---------------------------
      // Canvas sizing
      // ---------------------------
      function setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.round(rect.width * dpr);
        canvas.height = Math.round(rect.height * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        return { width: rect.width, height: rect.height };
      }

      // ---------------------------
      // Blocks simulation (deterministic loop)
      // ---------------------------
      const LOOP_SECONDS = 18; // ✅ 15–20s, and loops perfectly
      const BLOCK_COUNT = 96;

      let blocks = [];
      let loopOrigin = performance.now();

            function makeBlocks(width, height) {
        // Dense coverage: lots of slabs, mostly straight motion, heavy overlap.
        // We store everything in normalized units so HD record + screenshots match the live view perfectly.
        const margin = Math.max(22, width * 0.09);
        const marginN = margin / width;

        const minH = Math.max(18, height * 0.025);
        const maxH = Math.max(70, height * 0.09);

        const rows = 18;               // snap into bands so background rarely peeks through
        const rowJitter = 0.72;

        function pickBlend() {
          const r = Math.random();
          if (r < 0.42) return "multiply";
          if (r < 0.74) return "screen";
          if (r < 0.92) return "overlay";
          return "lighter";
        }

        function expandedColor() {
          const c = pickPaletteColorHsl();
          // Mostly palette-derived, but with a wider hue orbit for variety
          const big = Math.random() < 0.22;
          const shift = big ? (Math.random() * 140 - 70) : (Math.random() * 70 - 35);
          const hue = (c.h + shift + 360) % 360;
          const sat = clamp(c.s + (Math.random() * 26 - 8), 12, 100);
          const lit = clamp(c.l + (Math.random() * 24 - 10), 6, 94);
          return { hue, sat, lit };
        }

        blocks = [];

        // Main slabs
        for (let i = 0; i < BLOCK_COUNT; i++) {
          const dir = Math.random() < 0.5 ? 1 : -1; // 1 = left->right, -1 = right->left

          const h = clamp(minH + Math.random() * (maxH - minH), minH, maxH);
          const w = clamp(width * (0.22 + Math.random() * 0.78), width * 0.18, width * 0.98);

          // distribute y across rows for better coverage
          const row = (Math.random() * rows) | 0;
          const rowH = height / rows;
          const yBase = row * rowH;
          const y = clamp(yBase + (Math.random() - 0.5) * rowH * rowJitter, 0, height - h);

          const col = expandedColor();

          blocks.push({
            dir,
            yN: y / height,
            wN: w / width,
            hN: h / height,
            marginN,
            phase: Math.random(),
            // a little faster overall (still loops perfectly)
            speedInt: [2, 2, 3, 3, 4, 5][(Math.random() * 6) | 0],
            blend: pickBlend(),
            hue: col.hue,
            sat: col.sat,
            lit: col.lit,
            alpha: 0.22 + Math.random() * 0.22,
            blurN: (1.4 + Math.random() * 6.6) / height, // reduced halo
          });
        }

        // Thin accents (adds complexity without "halo")
        const ACCENTS = Math.floor(BLOCK_COUNT * 0.33);
        for (let i = 0; i < ACCENTS; i++) {
          const dir = Math.random() < 0.5 ? 1 : -1;
          const h = clamp(height * (0.012 + Math.random() * 0.022), height * 0.01, height * 0.04);
          const w = clamp(width * (0.28 + Math.random() * 0.70), width * 0.22, width * 0.98);

          const y = clamp(Math.random() * height, 0, height - h);
          const col = expandedColor();

          blocks.push({
            dir,
            yN: y / height,
            wN: w / width,
            hN: h / height,
            marginN,
            phase: Math.random(),
            speedInt: [3, 4, 4, 5, 6][(Math.random() * 5) | 0],
            blend: Math.random() < 0.6 ? "multiply" : "screen",
            hue: col.hue,
            sat: clamp(col.sat + 10, 10, 100),
            lit: clamp(col.lit + 4, 6, 96),
            alpha: 0.18 + Math.random() * 0.18,
            blurN: (0.8 + Math.random() * 3.2) / height
          });
        }

        // A few hero slabs for big overlaps
        for (let k = 0; k < 6; k++) {
          const dir = Math.random() < 0.5 ? 1 : -1;
          const col = expandedColor();
          const h = height * (0.11 + Math.random() * 0.14);
          const w = width * (0.78 + Math.random() * 0.42);
          const y = clamp((0.05 + Math.random() * 0.9) * height - h * 0.5, 0, height - h);

          blocks.push({
            dir,
            yN: y / height,
            wN: w / width,
            hN: h / height,
            marginN: marginN * 1.05,
            phase: Math.random(),
            speedInt: [1, 1, 2][(Math.random() * 3) | 0],
            blend: Math.random() < 0.5 ? "overlay" : "screen",
            hue: col.hue,
            sat: clamp(col.sat + 8, 10, 100),
            lit: clamp(col.lit + 10, 10, 96),
            alpha: 0.12 + Math.random() * 0.10,
            blurN: (1.2 + Math.random() * 6.0) / height
          });
        }
      }

      function clearBackground(targetCtx, width, height) {
        targetCtx.globalCompositeOperation = "source-over";
        targetCtx.globalAlpha = 1;
        targetCtx.fillStyle = `hsl(${bgHue}, ${bgSat}%, ${bgLight}%)`;
        targetCtx.fillRect(0, 0, width, height);

        // a soft base gradient
        targetCtx.globalAlpha = 0.12;
        const g = targetCtx.createLinearGradient(0, 0, width, height);
        g.addColorStop(0, `hsla(${(bgHue + 40) % 360}, ${clamp(bgSat + 18, 8, 70)}%, ${clamp(bgLight + 24, 10, 72)}%, 1)`);
        g.addColorStop(0.5, `hsla(${(bgHue + 170) % 360}, ${clamp(bgSat + 22, 8, 80)}%, ${clamp(bgLight + 18, 10, 66)}%, 1)`);
        g.addColorStop(1, `hsla(${(bgHue + 300) % 360}, ${clamp(bgSat + 14, 8, 70)}%, ${clamp(bgLight + 22, 10, 70)}%, 1)`);
        targetCtx.fillStyle = g;
        targetCtx.fillRect(0, 0, width, height);
        targetCtx.globalAlpha = 1;
      }

            function fadeBackground(targetCtx, width, height, tNorm) {
        // Clear a bit more each frame to reduce "halo" trails, but keep enough persistence for overlap patterns.
        targetCtx.globalCompositeOperation = "source-over";
        targetCtx.globalAlpha = 0.22;
        targetCtx.fillStyle = `hsl(${bgHue}, ${bgSat}%, ${bgLight}%)`;
        targetCtx.fillRect(0, 0, width, height);

        // very subtle looping sheen (kept minimal)
        targetCtx.save();
        targetCtx.globalCompositeOperation = "screen";
        targetCtx.globalAlpha = 0.022;

        const t = tNorm * Math.PI * 2;
        const x0 = width * (0.10 + 0.18 * Math.sin(t * 0.9));
        const y0 = height * (0.16 + 0.20 * Math.cos(t * 0.8));
        const x1 = width * (0.90 + 0.16 * Math.cos(t * 0.7));
        const y1 = height * (0.86 + 0.16 * Math.sin(t * 0.75));

        const g = targetCtx.createLinearGradient(x0, y0, x1, y1);
        g.addColorStop(0, `hsla(${(bgHue + 35) % 360}, ${clamp(bgSat + 18, 8, 70)}%, ${clamp(bgLight + 34, 10, 72)}%, 1)`);
        g.addColorStop(0.55, `hsla(${(bgHue + 170) % 360}, ${clamp(bgSat + 22, 8, 80)}%, ${clamp(bgLight + 26, 10, 66)}%, 1)`);
        g.addColorStop(1, `hsla(${(bgHue + 295) % 360}, ${clamp(bgSat + 16, 8, 70)}%, ${clamp(bgLight + 32, 10, 70)}%, 1)`);

        targetCtx.fillStyle = g;
        targetCtx.fillRect(0, 0, width, height);
        targetCtx.restore();

        targetCtx.globalAlpha = 1;
      }

      function roundedRect(targetCtx, x, y, w, h, r) {
        const rr = Math.min(r, w * 0.5, h * 0.5);
        targetCtx.beginPath();
        targetCtx.moveTo(x + rr, y);
        targetCtx.arcTo(x + w, y, x + w, y + h, rr);
        targetCtx.arcTo(x + w, y + h, x, y + h, rr);
        targetCtx.arcTo(x, y + h, x, y, rr);
        targetCtx.arcTo(x, y, x + w, y, rr);
        targetCtx.closePath();
      }

            function drawBlock(targetCtx, b, width, height, tNorm) {
        // de-normalize
        const y = b.yN * height;
        const h = b.hN * height;
        const w = b.wN * width;
        const margin = (b.marginN ?? 0.1) * width;

        const u = (tNorm * b.speedInt + b.phase) % 1;
        const travel = width + 2 * margin + w;

        let x;
        if (b.dir === 1) x = -margin - w + u * travel;
        else x = width + margin - u * travel;

        // subtle shimmer, but keep it mostly "blocky"
        const shimmer = 0.5 + 0.5 * Math.sin((tNorm + b.phase) * Math.PI * 2);
        const hueA = (b.hue + 14 * shimmer + 360) % 360;
        const hueB = (b.hue - 18 * shimmer + 360) % 360;

        const g = targetCtx.createLinearGradient(x, 0, x + w, 0);
        g.addColorStop(0, `hsla(${hueA}, ${b.sat}%, ${clamp(b.lit + 10, 4, 98)}%, 0)`);
        g.addColorStop(0.10, `hsla(${hueA}, ${b.sat}%, ${b.lit}%, 1)`);
        g.addColorStop(0.52, `hsla(${b.hue}, ${clamp(b.sat + 14, 0, 100)}%, ${clamp(b.lit + 6, 0, 100)}%, 1)`);
        g.addColorStop(0.90, `hsla(${hueB}, ${b.sat}%, ${b.lit}%, 1)`);
        g.addColorStop(1, `hsla(${hueB}, ${b.sat}%, ${clamp(b.lit + 10, 4, 98)}%, 0)`);

        targetCtx.save();
        targetCtx.globalAlpha = b.alpha;
        targetCtx.globalCompositeOperation = b.blend || "screen";

        const blur = clamp((b.blurN || 0) * height, 0, 10);
        targetCtx.shadowColor = `hsla(${b.hue}, ${b.sat}%, ${clamp(b.lit + 10, 0, 100)}%, 0.38)`;
        targetCtx.shadowBlur = blur;

        roundedRect(targetCtx, x, y, w, h, Math.min(18, h * 0.42));
        targetCtx.fillStyle = g;
        targetCtx.fill();

        // A crisp edge pass for pattern definition (no glow)
        targetCtx.shadowBlur = 0;
        targetCtx.globalAlpha = b.alpha * 0.35;
        targetCtx.globalCompositeOperation = (b.blend === "multiply") ? "source-over" : "overlay";
        targetCtx.strokeStyle = `hsla(${(b.hue + 40) % 360}, ${clamp(b.sat + 8, 0, 100)}%, ${clamp(b.lit + 14, 0, 100)}%, 0.9)`;
        targetCtx.lineWidth = Math.max(0.8, h * 0.06);
        roundedRect(targetCtx, x + 0.6, y + 0.6, w - 1.2, h - 1.2, Math.min(18, h * 0.42));
        targetCtx.stroke();

        targetCtx.restore();
      }

      function renderFrame(targetCtx, width, height, nowMs) {
        const tNorm = (((nowMs - loopOrigin) / 1000) % LOOP_SECONDS) / LOOP_SECONDS;

        fadeBackground(targetCtx, width, height, tNorm);

        // draw from back to front for nicer layering
        for (let i = 0; i < blocks.length; i++) {
          drawBlock(targetCtx, blocks[i], width, height, tNorm);
        }

        targetCtx.globalAlpha = 1;
        targetCtx.globalCompositeOperation = "source-over";
      }

      // ---------------------------
      // Animation
      // ---------------------------
      let animationId = null;
      let isPaused = false;
      let lastT = performance.now();

      // For high-quality recording we render to an offscreen 1080×1920 canvas.
      const REC_W = 1080;
      const REC_H = 1920;
      const recCanvas = document.createElement("canvas");
      recCanvas.width = REC_W;
      recCanvas.height = REC_H;
      const recCtx = recCanvas.getContext("2d", { alpha: false, desynchronized: true }) || recCanvas.getContext("2d");

      function hardResetVisuals(width, height) {
        clearBackground(ctx, width, height);
        clearBackground(recCtx, REC_W, REC_H);
      }

      function startAnimation(reseedAll = true) {
        if (animationId !== null) cancelAnimationFrame(animationId);

        const { width, height } = setupCanvas();

        if (reseedAll) {
          reseedPalette();
          updateSeedInUrl();
        }

        updateTitlePill();
        makeBlocks(width, height);
        hardResetVisuals(width, height);

        isPaused = false;
        lastT = performance.now();

        function animate(now) {
          if (isPaused) {
            animationId = null;
            return;
          }

          // clamp dt for stability
          const dt = Math.min(0.05, (now - lastT) / 1000);
          lastT = now;

          // advance loop origin only via now; dt is just to keep stable
          renderFrame(ctx, width, height, now);

          // if recording, also render HD frame
          if (isRecording) {
            // render with same loop phase but fixed 1080×1920
            renderFrame(recCtx, REC_W, REC_H, now);
          }

          animationId = requestAnimationFrame(animate);
        }

        animationId = requestAnimationFrame(animate);
      }

      function reseed() {
        loopOrigin = performance.now(); // start loop on a clean boundary
        startAnimation(true);
        setStatus("Reseeded • Tap canvas to reseed • Space = pause • S = screenshot • S = screenshot");
      }

      function togglePause() {
        isPaused = !isPaused;
        if (!isPaused && animationId === null) {
          lastT = performance.now();
          startAnimation(false);
        }
        setStatus(isPaused ? "Paused • Space = play" : "Playing • Space = pause");
      }

      // ---------------------------
      // Recording
      // ---------------------------
      let mediaRecorder = null;
      let recordedChunks = [];
      let isRecording = false;
      let stopTimer = null;

      // const btnReseed = document.getElementById("btnReseed");
      // const btnRecord = document.getElementById("btnRecord");
      // const btnStop = document.getElementById("btnStop");
      // const btnDownload = document.getElementById("btnDownload");
      // const statusEl = document.getElementById("status");

      function setStatus(msg) {
        statusEl.textContent = msg;
      }

      function pickBestMimeType() {
        const candidates = [
          "video/webm;codecs=vp9",
          "video/webm;codecs=vp8",
          "video/webm"
        ];
        for (const c of candidates) {
          if (window.MediaRecorder && MediaRecorder.isTypeSupported(c)) return c;
        }
        return "";
      }

      function startRecording() {
        if (isRecording) return;

        // ensure animation is running
        isPaused = false;

        // align to loop start for a perfect loop
        loopOrigin = performance.now();

        // reset visuals on both canvases
        const { width, height } = setupCanvas();
        makeBlocks(width, height);
        hardResetVisuals(width, height);

        // hide previous download
        btnDownload.style.display = "none";
        btnDownload.removeAttribute("href");

        recordedChunks = [];

        const stream = recCanvas.captureStream(60);
        const mimeType = pickBestMimeType();
        const opts = {
          mimeType: mimeType || undefined,
          videoBitsPerSecond: 12_000_000 // ✅ higher = cleaner gradients
        };

        try {
          mediaRecorder = new MediaRecorder(stream, opts);
        } catch (err) {
          setStatus("Recording failed (MediaRecorder not supported in this browser).");
          return;
        }

        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) recordedChunks.push(e.data);
        };

        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || "video/webm" });
          const url = URL.createObjectURL(blob);
          btnDownload.href = url;
          btnDownload.download = `holo-blocks-${getPaletteSlug()}-${REC_W}x${REC_H}-${Date.now()}.webm`;
          btnDownload.style.display = "inline-flex";
          setStatus("Done • Download video");
        };

        mediaRecorder.start();
        isRecording = true;

        // btnRecord.disabled = true;
        // btnStop.disabled = false;
        // btnReseed.disabled = true;

        setStatus("Recording… (18s) rendering at 1080×1920");

        stopTimer = setTimeout(() => {
          stopRecording();
        }, LOOP_SECONDS * 1000 + 60);
      }

      function stopRecording() {
        if (!isRecording) return;
        isRecording = false;

        if (stopTimer) { clearTimeout(stopTimer); stopTimer = null; }

        // btnRecord.disabled = false;
        // btnStop.disabled = true;
        // btnReseed.disabled = false;

        try {
          mediaRecorder.stop();
        } catch (e) {
          setStatus("Stopped");
        }
      }

            // ---------------------------
      // High-resolution screenshot (PNG)
      // ---------------------------
      function saveHiResScreenshot() {
        // ✅ “What you see is what you save”
        // We capture the CURRENT on-screen canvas pixels (including trails),
        // then upscale to at least ~2160×3840 for social posts.
        const srcW = canvas.width;
        const srcH = canvas.height;
        const targetH = 3840;
        const scale = clamp(targetH / srcH, 1, 4);
        const shotW = Math.round(srcW * scale);
        const shotH = Math.round(srcH * scale);

        const shotCanvas = document.createElement("canvas");
        shotCanvas.width = shotW;
        shotCanvas.height = shotH;
        const shotCtx = shotCanvas.getContext("2d");
        shotCtx.imageSmoothingEnabled = true;
        try { shotCtx.imageSmoothingQuality = "high"; } catch {}
        shotCtx.drawImage(canvas, 0, 0, shotW, shotH);

        shotCanvas.toBlob((blob) => {
          if (!blob) return;
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `holo-blocks-${getPaletteSlug()}-${shotW}x${shotH}-${Date.now()}.png`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 2000);
          setStatus(`Saved PNG • ${shotW}×${shotH}`);
        }, "image/png");
      }

// ---------------------------
      // Input
      // ---------------------------
      const wrap = document.getElementById("canvasWrap");
      const stage = document.getElementById("stage");

      function isInsideCanvas(e) {
        const rect = wrap.getBoundingClientRect();
        const x = e.touches ? e.touches[0].clientX : e.clientX;
        const y = e.touches ? e.touches[0].clientY : e.clientY;
        return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
      }

      function onStageClick(e) {
        // Don't hijack clicks on UI controls (this was blocking video downloads).
        if (e.target && e.target.closest && e.target.closest(".controls")) return;
        if (isInsideCanvas(e)) reseed();
        else togglePause();
      }

      function onStageTouch(e) {
        if (e.target && e.target.closest && e.target.closest(".controls")) return;
        // prevent scroll only when interacting with the canvas
        if (isInsideCanvas(e)) {
          e.preventDefault();
          reseed();
        }
      }

      stage.addEventListener("click", onStageClick);
      stage.addEventListener("touchstart", onStageTouch, { passive: false });

      // btnReseed.addEventListener("click", (e) => { e.preventDefault(); reseed(); });
      // btnRecord.addEventListener("click", (e) => { e.preventDefault(); startRecording(); });
      // btnStop.addEventListener("click", (e) => { e.preventDefault(); stopRecording(); });

      window.addEventListener("keydown", (e) => {
        if (e.key === " ") { e.preventDefault(); togglePause(); }
        if (e.key === "r" || e.key === "R") reseed();
        if (e.key === "v" || e.key === "V") startRecording();
        if (e.key === "s" || e.key === "S") saveHiResScreenshot();
        if (e.key === "Escape") stopRecording();
      });

window.addEventListener("resize", () => {
        // keep same palette but rebuild blocks for new aspect
        startAnimation(false);
      });

      // boot
      applyPaletteMode(0);
      updateTitlePill();
      loopOrigin = performance.now();
      startAnimation(true);
    </script>
  </body>
</html>
